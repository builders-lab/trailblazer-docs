{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Trailblazer","text":"<p>Status: Active Development</p> <p>Trailblazer is currently in Alpha. APIs and architectural patterns are subject to change. View the Roadmap</p> <p>Trailblazer is a hermetic, distributed build orchestration engine designed for high-performance CI/CD pipelines. It treats build steps as a Directed Acyclic Graph (DAG), enabling massive parallelism and deterministic outputs.</p>"},{"location":"#mission-objective","title":"\ud83c\udfaf Mission Objective","text":"<p>Designed for scale and modularity, Trailblazer aims to solve:</p> <ul> <li>Scalability: Moves beyond linear shell scripts by implementing a DAG-based execution model, allowing independent build targets to run concurrently across isolated containers.</li> <li>Resilience: Enforces hermetic builds by executing every step in ephemeral Docker containers, eliminating \"it works on my machine\" drift.</li> <li>Developer Velocity: Reduces cycle time via content-addressable caching, ensuring that artifacts (like <code>.o</code> files) are never rebuilt if the source hasn't changed.</li> </ul>"},{"location":"#quick-start","title":"\u26a1 Quick Start","text":"<p>Initialize the build system in your repository.</p> <p>```bash</p>"},{"location":"#clone-the-repository","title":"Clone the repository","text":"<p>git clone https://github.com/builders-lab/trailblazer-core</p>"},{"location":"#generate-the-dependency-graph","title":"Generate the dependency graph","text":"<p>./trailblazer plan --target=//src/main</p>"},{"location":"#execute-the-build","title":"Execute the build","text":"<p>./trailblazer build</p>"},{"location":"architecture/roadmap/","title":"Engineering Roadmap","text":"<p>This document outlines the strategic development phases for Trailblazer. The project follows an iterative approach, moving from a monolithic build prototype to a distributed, DAG-based execution engine.</p>"},{"location":"architecture/roadmap/#phase-1-the-monolith-mvp","title":"Phase 1: The Monolith (MVP)","text":"<p>Objective: Establish the baseline CI loop.</p> <ul> <li> VCS Polling: Implement a watcher service to detect changes in the target GitHub repository.</li> <li> Sandboxed Build: On change detection, pull source code into a single, isolated Docker container.</li> <li> Artifact Simulation: execute the build command and mock the artifact upload process (logging success/failure only).</li> <li> Outcome: A working \"Input -&gt; Process -&gt; Output\" loop with zero caching or parallelism.</li> </ul>"},{"location":"architecture/roadmap/#phase-2-dag-based-execution-engine-core","title":"Phase 2: DAG-Based Execution Engine (Core)","text":"<p>Objective: Transition to a graph-based build system for parallelism.</p> <p>This is the core architectural shift. We move from executing a script to executing a Directed Acyclic Graph (DAG).</p> <ul> <li> Manifest Parsing: Implement a parser for <code>BUILD</code> files to identify build targets and dependencies.</li> <li> Graph Generation: Algorithmically plot the dependency graph from the parsed targets.</li> <li> Container orchestration:<ul> <li>Provide a <code>Dockerfile</code> defining the build environment (compilers, linkers).</li> <li>Spin up separate containers for independent graph nodes.</li> </ul> </li> <li> Aggregation: A final \"Linker\" container collects outputs from upstream nodes and produces the final binary.</li> <li> Constraint: No cross-dependencies between parallel threads in this phase to reduce complexity.</li> </ul>"},{"location":"architecture/roadmap/#phase-3-optimization-caching","title":"Phase 3: Optimization &amp; Caching","text":"<p>Objective: Reduce build times through artifact reuse.</p> <ul> <li> Fingerprinting: Implement hashing for source files (content-addressable storage).</li> <li> Object Caching: Store compiled <code>.o</code> files mapped to their source hash.</li> <li> Cache Invalidation: Implement Time-To-Live (TTL) or LRU policies for the build cache.</li> </ul>"},{"location":"architecture/system-design/","title":"High-Level Design","text":"<p>System Architecture Overview</p> <p>Trailblazer is a distributed build orchestration system designed to parallelize compilation workflows through containerized execution. Unlike traditional CI pipelines that execute linear scripts, Trailblazer constructs a dependency-aware execution graph and schedules independent tasks concurrently.</p> <p>The system emphasizes deterministic builds, horizontal scalability, and efficient resource utilization through ephemeral execution environments.</p> <p>Execution Flow (Phase 2)</p> <p>Trailblazer follows a Split\u2013Merge execution model composed of four primary components.</p> <ol> <li>Trailblazer Controller (Orchestration Layer)</li> </ol> <p>The Controller acts as the central coordination unit responsible for managing the lifecycle of a build pipeline.</p> <p>Responsibilities</p> <p>Ingestion Receives repository change events through webhooks or polling mechanisms and initializes build pipelines.</p> <p>DAG Generation Parses the project\u2019s BUILD configuration to construct a Directed Acyclic Graph (DAG) representing task dependencies.</p> <p>Scheduling Continuously evaluates the DAG to identify executable nodes (tasks with no unresolved dependencies) and dispatches them to the execution layer.</p> <ol> <li>Ephemeral Workers (Execution Layer)</li> </ol> <p>Workers are stateless, short-lived Docker containers created dynamically for each node in the dependency graph.</p> <p>Key Characteristics</p> <p>Isolation Each worker executes within a clean container environment defined by the project\u2019s Dockerfile, ensuring reproducible builds.</p> <p>Parallel Execution Independent compilation targets run concurrently. For example, utils.c and network.c may compile simultaneously if no dependency exists between them.</p> <p>Lifecycle Management Containers terminate immediately after task completion, freeing compute and memory resources.</p> <ol> <li>Shared Volume / Artifact Store</li> </ol> <p>A temporary storage layer mounted across all worker containers.</p> <p>Purpose</p> <p>Serves as the data exchange mechanism between isolated execution units.</p> <p>Stores intermediate artifacts such as object files (.o) produced during compilation.</p> <p>Workflow</p> <p>Workers write intermediate outputs to the shared volume.</p> <p>Downstream nodes consume these artifacts as inputs for subsequent stages.</p> <ol> <li>Linker (Aggregation Node)</li> </ol> <p>The Linker represents the terminal node within the dependency graph.</p> <p>Behavior</p> <p>Trigger Condition Executes only after all upstream dependencies complete successfully.</p> <p>Output Stage Aggregates object files into a final executable and publishes the result to the long-term artifact repository.</p> <p>Design Principles Hermetic Execution</p> <p>Every build step runs within a freshly instantiated container environment. This eliminates configuration drift and ensures that builds remain deterministic across machines and environments.</p> <p>DAG-Driven Parallelism</p> <p>Traditional CI systems execute tasks sequentially:</p> <p>Step A \u2192 Step B \u2192 Step C</p> <p>Trailblazer analyzes dependency relationships to maximize concurrency:</p> <p>Independent nodes execute immediately.</p> <p>Dependent nodes wait only for required upstream tasks.</p> <p>As a result, total build time approaches:</p> <p>Max(Critical Path Duration)</p> <p>instead of:</p> <p>Sum(All Step Durations)</p> <p>Future Roadmap (Phase 3) Content-Addressable Caching</p> <p>Input hashing (source code, flags, environment metadata) will allow Trailblazer to skip execution for unchanged nodes, reducing redundant work.</p> <p>Distributed Worker Clusters</p> <p>Execution will extend beyond a single host, enabling horizontal scaling across multiple physical nodes in cluster mode.</p>"}]}